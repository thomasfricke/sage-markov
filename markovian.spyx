###################################################################################
#
#   This file is part of Sage-Markov.
#
#   Sage-Markov is free software: you can redistribute it and/or modify
#    it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    Sage-Markov is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU AFFERO GENERAL PUBLIC LICENSE for more details.
#   You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE
#   along with Sage-Markov.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

import os
home=os.getcwd()
dimension=1

#clang c
#cargs -std=c99
#cinclude home
#cfile topology.c  model.c logclass.c rand55.c rand55static.c sagemarkov.c

from sage.plot.plot import list_plot
from math import *

ctypedef unsigned long size_t
ctypedef double reactivity_t

cdef extern from "sagemarkov.h":
  cdef struct cell:
    void * LC_DERIVED
    unsigned long n

  cell * cells

  size_t number_of_cells
  unsigned long seed

  int topological_dimension
  size_t create_topology(const int dimension, const size_t edge)
  size_t * topological_sizes

  int create_walk(size_t init_number_of_cells, unsigned long init_seed, double timescale)
  int destroy_walk()

  reactivity_t reactivity(size_t index)
  reactivity_t global_reactivity()

  void update_reactivity(size_t index)
  int run_walk(size_t iterations)


  double markov_time, timescale
  double decay_rate
  double diffusion_rate

def index(*array):
  min=topological_dimension
  if len(array) < topological_dimension:
     min=len(array)

  i=0;
  for d in range(min):
    i+=array[d] * topological_sizes[d]

  return i

def coords(index):
  a=[]

  for d in range(topological_dimension):
    dc=index % topological_sizes[d+1]
    a.append(dc/topological_sizes[d])
    index -= dc
  return a

def matches(index,*ranges):
  min=topological_dimension
  if len(ranges) < topological_dimension:
    min=len(ranges)

  crd=coords(index)
  i=0
  for r in ranges:
    if r != None and not ( crd[i] in r ):
        return False
    i+=1

  return True

def update(index):
  if index < 0 or index >= number_of_cells:
    raise MarkovianRangeException("index=%d" % index,"the index must be in the range=0 .. %d" % number_of_cells)
  update_reactivity(index)

class multi_range:

    def __init__(self, *ranges, return_fun=lambda l: l):
      self.return_fun = return_fun
      self.iterators = []
      self.ranges = ranges
      self.values = []
      for r in self.ranges:
        i=iter(r)
        self.iterators.append(i)
        self.values.append(i.next())

      self.dim = len( ranges)

    def __iter__(self):
      while True:
        yield self.return_fun(self.values)
        d=0
        while d < self.dim:
          try:
            self.values[d] = self.iterators[d].next()
          except StopIteration:
            i=iter(self.ranges[d])
            self.iterators[d]=i
            self.values[d]=i.next()
            d += 1
            continue
          else:
            break
        else:
          raise StopIteration()

class MarkovianRangeException(BaseException):
  """Range check exception"""
  def __init__(self, expr, msg):
        self.args = (expr, msg)

class Markovian:

  def __init__(self,dimension,size, seed=0, timescale=1, initial=None):
    self.create(dimension, size, seed, timescale)
    self.dimension=dimension
    self.size=size
    self.seed=seed
    self.timescale=timescale
    self.initial=initial

    if initial:
      self.initial_conditions(initial)

  def create(self,dimension, size, seed=0, timescale=1):
    if not size >0:
      raise MarkovianRangeException("size=%d" % size,"the size must be a positive number")

    if not timescale >0:
      raise MarkovianRangeException("timescale=%f" % timescale,
        "the timescale must be a positive number")

    number_of_cells=create_topology(dimension, size)
    self.number_of_cells=number_of_cells
    return create_walk(number_of_cells, seed, timescale)

  def destroy(self):
    return destroy_walk()

  def cell(self,index,n=None):

    if index < 0 or index >= number_of_cells:
      raise MarkovianRangeException("index=%d" % index,"the index must be in the range=0 .. %d" % number_of_cells)

    if n:
      if n<0:
        raise MarkovianRangeException("n=%d" % n,"the number of walkers n must be n >= 0")
      cells[index].n=n
      update(index)

    return cells[index].n


  def reactivity(self,index=None):
    if index:
      return reactivity(index)
    else:
      return global_reactivity()

  def diffusion_rate(self, d=None):
    if d:
      diffusion_rate=d

    return diffusion_rate

  def volume(self):
    return topological_volume()

  def reinit(self):
    self.destroy()

    self.create(dimension=self.dimension,
      size=self.size,seed=self.seed,timescale=self.timescale)

    if self.initial:
      self.initial_conditions(self.initial)

  def run(self,iterations):
    if run_walk(iterations) == -1 and self.number_of_cells > 0 :
      reinit()
      run_walk(iterations)

    return markov_time

  def time(self):
    return markov_time

  def decay_rate(self,r=None):
    global decay_rate
    if r:
      decay_rate=r

    return decay_rate

  def initial_conditions(self,initial):
    self.initial=initial
    for k in initial:
      self.cell(k,initial[k]+self.cell(k))

  def all_cells(self, cond=lambda index: True,
                range_iterator= None) :
    if range_iterator==None:
      range_iterator=range(self.number_of_cells )

    ne={}
    for i in range_iterator:
      if cond(i):
        ne[i]=self.cell(i)
    return ne

  def non_empty_cells(self):
    return self.all_cells(cond = lambda i: self.cell(i) > 0)

  def slice(self, ranges):
    return self.all_cells(cond=lambda i: matches(i,*ranges))

  def loop(self,*ranges):
    min = len(ranges)
    if self.dimension < min:
      min = self.dimension

    loop_ranges =[]

    for l in range(self.dimension):
      if l<min and ranges[l]:
        rl = ranges[l]
        if  rl == None:
          loop_ranges.append(range(self.size))
        else:
          if isinstance(rl,list):
            loop_ranges.append(rl)
          else:
            loop_ranges.append(range(rl,rl+1))
      else:
        loop_ranges.append(range(self.size))

    return loop_ranges

  def analytic(self):
    return lambda x: self.initial[number_of_cells/2] \
                     *exp( -pow(x-number_of_cells/2,2)/( 2*self.time() ) - self.decay_rate()*self.time() ) \
                     /sqrt( 2*pi*self.time() )

  def plot(self):
    return list_plot(self.non_empty_cells())

  def analytic_plot(self,color='red',plotjoined=True):
    a=self.non_empty_cells()
    for i in a:
      a[i]=self.analytic()(i)

    return list_plot(a,color=color,plotjoined=plotjoined)

  def sum_walker(self):
    sum=0
    for c in self.all_cells():
      sum = sum + cells[c].n

    return sum

  def value_by_time(self,fun,steps=1000):
    time_series={}

    while self.reactivity() > 0:
      time_series[self.time()]=fun()
      self.run(steps)

    return time_series

  def write_to_file(self,filename="out.dat"):
    f=open(filename,"w")
    for c in self.all_cells():
        sim = self.cell(c)
        an  = self.analytic()(c)
        err = sqrt(self.cell(c))
        f.write('{0:d}\t{1:d}\t{2:f}\t{3:f}\n'.format(c, sim, an, err))
    f.close()

  def info(self):
    dict=self.__dict__
#    dict["non_empty_cells"]=self.non_empty_cells()
    return dict

  @classmethod
  def demo(cls,dimension=2, size=100, initial=None,decay_rate=0.01):

    m=Markovian(dimension, size,initial=initial)

    if m.initial == None:
        center=0
        for d in range(dimension):
            center += topological_sizes[d+1]/2
        m.initial_conditions({ center: 100000})

    m.decay_rate(decay_rate)
    m.run(1000000)
#    m.write_to_file()
    return m

  @classmethod
  def gnuplot_string(cls):
    return  'reset\np "out.dat" u 1:2:4 t "simulation" with err, "out.dat" u 1:3 t "analytic" with linespoints smooth unique'
