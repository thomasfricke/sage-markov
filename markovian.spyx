###################################################################################
#
#   This file is part of Sage-Markov.
#
#   Sage-Markov is free software: you can redistribute it and/or modify
#    it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    Sage-Markov is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU AFFERO GENERAL PUBLIC LICENSE for more details.
#   You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE
#   along with Sage-Markov.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

import os
home=os.getcwd()

#clang c
#cargs -std=c99
#cinclude home
#cfile randomwalk.c logclass.c rand55.c rand55static.c sagemarkov.c

from   sage.plot.plot import list_plot
from math import *

ctypedef unsigned long size_t
ctypedef double reactivity_t

cdef extern from "sagemarkov.h":
  cdef struct cell:
    void * LC_DERIVED
    unsigned long n
    
  cell * cells
  
  int number_of_cells
  unsigned long seed

  int create_walk(size_t init_number_of_cells, unsigned long init_seed, double timescale)
  int destroy_walk()
  
  reactivity_t reactivity(size_t index)
  reactivity_t global_reactivity()
  
  void update_reactivity(size_t index)
  void getcell(size_t index)
  void run_walk(size_t iterations)
  
  
  double markov_time
  double decay_rate
  double diffusion_rate

class MarkovianRangeException(BaseException):
  """Range check exception"""
  def __init__(self, expr, msg):
        self.expr = expr
        self.msg = msg

class Markovian:
  
  def __init__(self,number_of_cells, seed=0, timescale=1, initial=None):
    self.create(number_of_cells, seed, timescale)
    if initial:
      self.initial_conditions(initial)
    
  def create(self,number_of_cells, seed=0, timescale=1):
    if not number_of_cells >0:
      raise MarkovianRangeException("number_of_cells=%d" % self.number_of_cells(),"the number of cells must be a positive number")
   
    if not number_of_cells >0:
      raise MarkovianRangeException("timescale=%f" % timescale,
        "the timescale must be a positive number")
    
    return create_walk(number_of_cells, seed, timescale)

  def destroy(self):
    return destroy_walk()

  def update(self,index):
    if index < 0 or index >= self.number_of_cells():
      raise MarkovianRangeException("index=%d" % index,"the index must be in the range=0 .. %d" % self.number_of_cells())
    update_reactivity(index)
  
  def reactivity(self,index=None):
    if index:
      return reactivity(index)
    else: 
      return global_reactivity()
      
  def diffusion_rate(self, d=None):
    if d:
      diffusion_rate=d
    
    return diffusion_rate
  
  def cell(self,index,n=None):

    if index < 0 or index >= self.number_of_cells():
      raise MarkovianRangeException("index=%d" % index,"the index must be in the range=0 .. %d" % self.number_of_cells())
    
    if n:
      if n<0:
        raise MarkovianRangeException("n=%d" % n,"the number of walkers n must be n >= 0")
      cells[index].n=n
      self.update(index)
    return cells[index].n
  
  def number_of_cells(self):
    return number_of_cells
  
  def run(self,iterations):
    run_walk(iterations)
    return markov_time
  
  def time(self):
    return markov_time
  
  def decay_rate(self,r=None):
    global decay_rate
    if r:
      decay_rate=r
      
    return decay_rate
  
  def initial_conditions(self,initial):
    self.initial=initial
    for k in initial:
      self.cell(k,initial[k]+self.cell(k))
  
  def all_cells(self, cond=lambda index: True):
    ne={}
    for i in range(self.number_of_cells() ):
      if cond(i) > 0:
        ne[i]=self.cell(i)
    return ne
    
  def non_empty_cells(self):
    return self.all_cells(cond = lambda i: self.cell(i) > 0)

  def analytic(self):
    return lambda x: self.initial[number_of_cells/2]*exp( -pow(x-number_of_cells/2,2)/( 2*self.time() ) ) /sqrt( 2*pi*self.time() )
    
  def plot(self):
    return list_plot(self.non_empty_cells())

  def analytic_plot(self,color='red',plotjoined=True):
    a=self.non_empty_cells()
    for i in a:
      a[i]=self.analytic()(i)
    
    return list_plot(a,color=color,plotjoined=plotjoined)
  
  def reactivity_by_time(self,steps=1000):
    time_series={}
   
    while self.reactivity() > 0:
      time_series[self.time()]=self.reactivity()
      self.run(steps)
      
    return time_series
    
m=Markovian(100,initial={50: 100000})
m.decay_rate(0.1)
