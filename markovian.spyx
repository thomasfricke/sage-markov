###################################################################################
#
#   This file is part of Sage-Markov.
#
#   Sage-Markov is free software: you can redistribute it and/or modify
#    it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    Sage-Markov is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU AFFERO GENERAL PUBLIC LICENSE for more details.
#   You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE
#   along with Sage-Markov.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

import os
home=os.getcwd()
dimension=1

#clang c
#cargs -std=c99
#cinclude home
#cfile topology.c  model.c logclass.c rand55.c rand55static.c sagemarkov.c

from sage.plot.plot import list_plot
from math import *

ctypedef unsigned long size_t
ctypedef double reactivity_t

cdef extern from "sagemarkov.h":
  cdef struct cell:
    void * LC_DERIVED
    unsigned long n
    
  cell * cells
  
  size_t number_of_cells
  unsigned long seed

  size_t create_topology(const int dimension, const size_t edge)

  int create_walk(size_t init_number_of_cells, unsigned long init_seed, double timescale)
  int destroy_walk()
  
  reactivity_t reactivity(size_t index)
  reactivity_t global_reactivity()
  
  void update_reactivity(size_t index)
  void getcell(size_t index)
  int run_walk(size_t iterations)
  
  
  double markov_time, timescale
  double decay_rate
  double diffusion_rate

class MarkovianRangeException(BaseException):
  """Range check exception"""
  def __init__(self, expr, msg):
        self.args = (expr, msg) 

class Markovian:
  
  def __init__(self,dimension,size, seed=0, timescale=1, initial=None):
    self.create(dimension, size, seed, timescale)
    if initial:
      self.initial_conditions(initial)
    
  def create(self,dimension, size, seed=0, timescale=1):
    if not size >0:
      raise MarkovianRangeException("size=%d" % size,"the size must be a positive number")
   
    if not timescale >0:
      raise MarkovianRangeException("timescale=%f" % timescale,
        "the timescale must be a positive number")

    number_of_cells=create_topology(dimension, size)
    return create_walk(number_of_cells, seed, timescale)

  def destroy(self):
    return destroy_walk()

  def update(self,index):
    if index < 0 or index >= self.number_of_cells():
      raise MarkovianRangeException("index=%d" % index,"the index must be in the range=0 .. %d" % self.number_of_cells())
    update_reactivity(index)
  
  def reactivity(self,index=None):
    if index:
      return reactivity(index)
    else: 
      return global_reactivity()
      
  def diffusion_rate(self, d=None):
    if d:
      diffusion_rate=d
    
    return diffusion_rate
  
  def cell(self,index,n=None):

    if index < 0 or index >= self.number_of_cells():
      raise MarkovianRangeException("index=%d" % index,"the index must be in the range=0 .. %d" % self.number_of_cells())
    
    if n:
      if n<0:
        raise MarkovianRangeException("n=%d" % n,"the number of walkers n must be n >= 0")
      cells[index].n=n
      self.update(index)
    return cells[index].n
  
  def number_of_cells(self):
    return number_of_cells

  def size(self):
    return topological_sizes[1]

  def reinit(self):
    number_of_cells= self.number_of_cells()
    self.destroy()
    self.create(number_of_cells,seed,timescale)
    if self.initial:
      self.initial_conditions(self.initial)
        
  def run(self,iterations):
    if run_walk(iterations) == -1 and self.number_of_cells() > 0 :
      reinit()
      run_walk(iterations)

    return markov_time
  
  def time(self):
    return markov_time
  
  def decay_rate(self,r=None):
    global decay_rate
    if r:
      decay_rate=r
      
    return decay_rate
  
  def initial_conditions(self,initial):
    self.initial=initial
    for k in initial:
      self.cell(k,initial[k]+self.cell(k))
  
  def all_cells(self, cond=lambda index: True):
    ne={}
    for i in range(self.number_of_cells() ):
      if cond(i) > 0:
        ne[i]=self.cell(i)
    return ne
    
  def non_empty_cells(self):
    return self.all_cells(cond = lambda i: self.cell(i) > 0)

  def analytic(self):
    return lambda x: self.initial[number_of_cells/2] \
                     *exp( -pow(x-number_of_cells/2,2)/( 2*self.time() ) - self.decay_rate()*self.time() ) \
                     /sqrt( 2*pi*self.time() )

  def plot(self):
    return list_plot(self.non_empty_cells())

  def analytic_plot(self,color='red',plotjoined=True):
    a=self.non_empty_cells()
    for i in a:
      a[i]=self.analytic()(i)
    
    return list_plot(a,color=color,plotjoined=plotjoined)
    
  def sum_walker(self):
    sum=0
    for c in self.all_cells():
      sum = sum + cells[c].n
      
    return sum
  
  def value_by_time(self,fun,steps=1000):
    time_series={}
   
    while self.reactivity() > 0:
      time_series[self.time()]=fun()
      self.run(steps)
      
    return time_series

  def write_to_file(self,filename="out.dat"):
    f=open(filename,"w")
    for c in self.all_cells():
        sim = self.cell(c)
        an  = self.analytic()(c)
        err = sqrt(self.cell(c))
        f.write('{0:d}\t{1:d}\t{2:f}\t{3:f}\n'.format(c, sim, an, err))
    f.close()

  
  @classmethod
  def demo(cls,dimension=2, size=100, initial={50: 100000},decay_rate=0.01):

    m=Markovian(dimension, size,initial=initial)
    m.decay_rate(decay_rate)
    m.run(1000000)
#    m.write_to_file()
    return m

  @classmethod
  def gnuplot_string(cls):
    return  'reset\np "out.dat" u 1:2:4 t "simulation" with err, "out.dat" u 1:3 t "analytic" with linespoints smooth unique'
